#summary Elastic Cloud Manage System（ECMS） 概要设计

= Elastic Cloud Manage System（ECMS） 概要设计 =


== 背景介绍 ==
EMCS是为用户提供按需分配物理资源的基础服务平台 ——Infrastructure As a Service。EMCS 主要借助虚拟机技术实现物理计算机资源（计算资源、存储资源、网络资源等）的再划分、隔离、以及现场分配和回收。用户已完全独占方式获得虚拟机实例（其上已运行标准操作系统），具体使用方式也由用户自裁。

== ECMS设计目标 ==
 * EMCS的初期设计目标是:管理虚拟机和管理虚拟磁盘。其与现行的诸多管理系统最大不同就在于——由于虚拟磁盘的存在，我们虚拟机调度已经与具体宿主机无关，可以在整个集群中自由迁移（离线和在线）.
 * EMCS的后期设计目标:在无需修改任何网络基础架构的前提下，自由实现虚拟的二层网络，从而能为大客户提供和其实际独立机房类似的网络环境（其上的网络管理软件、如dhcp等都可继续使用).

== ECP设计特性 == 
=== 基本设计特性 ===
 * 虚拟机特性方面
# 支持按用户定义需动态创建、销毁虚拟磁盘.
  # 支持为给定虚拟机动态挂载、卸载虚拟磁盘.
  # 支持按用户定义资源配置创建和销毁虚拟机.
  # 支持随时关闭、启动、暂停、恢复虚拟机.
 * 虚拟机集群控制系统特性方面
  # 支持物理机集群在线扩容.
  # 支持虚拟机和宿主机状态实时监控. 
  # 支持系统管理的元数据安全.
=== 有待支持的特性 === 
 * 虚拟机特性方面
  # 支持运行时动态改变虚拟机所使用的资源（包括内存、CPU、磁盘、网卡等.
  # 支持用户自定义image（目前只支持系统预置镜像）.
  # 支持Kvm（目前支持Xen）.
 * 虚拟机集群控制系统特性方面
  # 支持虚拟子网 —— 支持用户子组建三层／二层子网.
  # 支持集群范围的动态负载均衡——VM需要又控制系统按负载情况动态迁移，已均匀压力.
  # 用户权限认证体系.
  # WEB UI系统.
=== 基本架构 ===
ECMS 的系统架构采用传统的MASTER/SLAVE模式，分别对应——总控服务 Master Service  和 宿主机控制服务Node Controller.
 * Master Service负责
  # 系统原数据管理:维护系统各种资源数据，以及控制和状态数据
  # 系统命令处理:负责处理虚拟机控制、监控等各种管理命令处理
  # 系统负载监控
  # 虚拟机运行状态监控
 * Node Controller负责
  # 按照总控服务指示执行具体虚拟机类命令
  # 监控虚拟机运行状态
  # 监控宿主机运行状态
=== 技术选型 === 
  ** 虚拟机平台我们选用业已成熟的机器虚拟机（Machine Virtualization）平台 —— Xen.Xen平台为我们提供hypervisor、device model、管理工具等丰富的管理工具，而且文档和使用人群也最为广泛.
  ** ECMS 实现采用面向分布系统的ERLANG语言实现,erlang 的丰富的OTP库和消息处理潜质是我们实现分布式调度的不二选择
  ** 虚拟机控制采用shell脚本继承管理类命令实现（暂不采用api接口编程实现），虽然不很专业，但可满足我们当前需求
=== Master Service 和Node Controller 设计概要 ===
==== Master Service 消息处理 ====
Master Serivce 消息处理采用：异步消息接收进程  +  多进程（erlang中是协程，不过我们文中仍成其进程吧）同步消息处理模型（类似于半同步半异步模型，只不过erlang协程很轻，所以现场创建、使用完销毁即可，不需要像传统方式那样以线程池实现之）。
==== 实现提示 ====
消息处理采用Erlang 中 gen_server 框架实现,具体实现有如下考虑：
 * handle_call 中spawn新进程负责具体的消息处理；
 * 回应句柄(From)需要告诉消息处理例程，以便命令执行完毕后，进行回应。
 * handle_call中不负责消息回应，而是采用noreply模式，以防止堵塞后续命令；
伪代码片如下 ：
{{{
handle_call({foo,X}, From, State) -> 
    	spawn_link(fun() -> do_cmd_process(State, X, From) end),
    	{noreply, State}.  
do_cmd_process(State, X, From) ->
        % 获得node controller的reference
        {Node,Nc_name}  =  get_node_contrllor(X,State) 
        % 构造给node controller的命令消息
        {Msg_to_nc} = build_nc_msg (X,State)
        % 发送消息给node controller
        {Node,Ncname} ! Msg,
        receive
           {{Node,Ncname} , Res} ->  
               %处理从node controller的响应消息
               do_replay_process(); 
      	   {'DOWN', {Node,Nc_name}, _, _, _} ->
               %处理node 宕机事件
               do_node_down_process(); 
           after 5000 - > 
 	       %通讯超时处理 
               do_timeout_process()
         end.
         gen_server:reply(From, Reply).  %最后回应给客户端
}}}
注：
 * Receive 处理属于异步消息处理，我们还可以简化成同步消息处理——采用gen_server:call({Node,Ncname},Msg,Timeout}代替更为简便。
 * do_cmd_process 在单独进程中执行，且会存在修改元数据等动作所以，所以对元数据修改需要枷锁。erlang中是采用transaction对数据库表枷锁。










