#summary 快照区间下段回收设计

=  快照区间下段回收设计 =

Log Structure的存储系统都跑不了旧数据回收这个环节。回收数据的算法好坏不但影响到磁盘占用率，更会影响到和读写访问性能。根据个人经验来看，
旧数据回收也是容易出bug的地方（而且这里的bug很可能破坏数据），因此我们特别强调段回收算法和策略，单独作为一个子模块加以设计和实施。

= 算法概述 =
我们知道，HLFS的inode结构会记录（通过各级索引）逻辑块和其物理存储地址的映射关系，也就是通过逻辑块号能找到其存储块位置。在这个前提下，我们要判断一个log中的存储块(data block)是否是旧数据，其实只需要根据该存储块是否能被给定inode索引到来判断——能索引到说明是活跃块（alive block),不能被索引到则是旧数据块（old block)。如果一个段中的所有数据块都是旧数据块，那么这个段文件则可被直接回收（直接删除段文件即可——我们称为简单回收）。 

= 强制回收段文件 =
简单回收要求一个段被回收要求绝对不存在活跃块。但是很有可能一个段中只有少量活跃块，这种情况下不回收其实在是种浪费，所以我们想办法搬迁这写少量的活跃块——将其以新数据块形式写入新log,从而“帮助”该段达到无活跃块状态，进而能被回收。 我们称其为 move & remove 策略。

= 快照条件下段回收 =
在快照情况下回收段文件：快照可以说是段回收的拦路虎，因为其将需要固化历史版本，使得段回收的范围不再是全局性，而是只能按照快照区间进行——和无快照环境相比，参照的inode结构不再是次新inode，而是上游快照(up snapshot）所在的inode。<br>
另外，强制回收段的方式在快照条件下很难适用，因为一旦搬迁某个快照区间的某个block，则意味着破坏了后续inode的寻址（无法再找到搬迁后的块）。到目前为止我们还没找到一个高效解决该问题的方法，所以快照间的段回收目前不进行强制回收动作。

= 段回收相关策略 =
 # .分步执行策略—— 我们将整个段回收分为两个主要阶段：“段统计”，“段搬迁” 和一个辅助阶段“段删除”。对于“非快照区间内”的段回收过程分为“段统计”和“段搬迁”两个阶段——“段统计”和“段搬迁”分别对应“简单回收”和“强制回收”。
   * "段统计”阶段计算段中块的活跃率等统计信息，如果无活跃块的段文件可以直接删除。对于不能直接删除的段，则生成一个"段统计文件"，每个段的统计信息记录为一项(称为"段统计记录")。在统计过程对于非快照区间使用的参照inode用次新inode。
   * "段搬迁" 阶段执行强制搬迁过程，根据段统计结果中那些活跃块较少的段（低于给定水位线），进行move & remove 操作 —— 注意这是个模糊判断，因为段统计时刻和段搬迁时刻之间可能已经有很多改变，统计时alive block可能已经是非old block了（但old block不会变为alive block)，所以段统计是各非精确的参考值。段搬迁需要修改该段的段统计记录（追加写入新的段统计记录，alive block此刻已经为0）。对于“快照区间"段回收过程只包括“段统计阶段"。
   * "段删除" 阶段其实段删除就意味着数据销毁（从hdfs中删除，回收存储空间），所以我们采取谨慎策略，删除动作都不和段统计和搬迁过程混合，而是后期单独执行。这个过程主要检查段统计记录，发现alive block为0的段，进行删除）。
 # 推拉执行策略—— 对于段统计阶段的操作，可采用本地客户端“拉模式”进行——也就是说将段数据读到本地，在本地执行统计，然后更新段统计文件；也可采用map/reduce“推模式“进行——也就是说到段所在机器就近计算段信息统计。
 # 带外执行和带内执行策略 —— "段统计"过程采用带外执行策略，也就是说由独立的standalone程序（拉模式）或者M/R任务执行（推模式）执行，其运行和hlfs在线系统无关；而“段搬迁”过程要带内执行，需要在hlfs写入流程中加入搬迁任务，原因和具体做法见下文。
 # HDFS使用中的文件操作已经采用强制锁保护，不允许同时两个写者操作文件，如果有读者也不允许删除文件。所以上述过程中更新或者删除文件时如报错—JAVA 是IOEXCEPTION,C接口就是open 反错",说明文件此刻被占用，retry即可；我们读取访问文件时要注意，不能长期持有文件句柄，将文件数据读取后或者数据写入后，即要关闭文件句柄。对于local mode下文件访问不是强制锁而是非强制锁，所以理论上有可能出现写乱情况，但实际中我们追加写操作数据小于4096(linux保证4096内追加的原子性）,所以不大会些乱。

= 名词解释 =
 * 快照区间： 两个快照之间的连续段。按照时间序左区间快照叫下游快照down snapshot，右区间快照叫up snapshot。
 * 非快照区间：最后一个快照之后的所有连续段。如果没有任何一个快照，全部段都属于非快照区间，如果有快照，则最后一个快照到当前操作段都叫非快照区间。
 * 活跃块：
 * 旧块：
 * 次新inode: 我们定义为当前段的prev段的最后一个inode为次新inode。使用次新inode而非最新inode纯粹是为了简单，找一个不变量。

= 基本数据结构 =
{{{

struct snapshot {
     uint64_t timestamp;
     uint64_t inode_addr;
     char sname[HLFS_FILE_NAME_MAX];
     char up_sname[HLFS_FILE_NAME_MAX]; /* for tree style snapshot */
};

struct seg_usage_t{
         uint64_t seg_no；
         char up_snapshot[128]；up快照，对于非快照区间的段而言，这个值可以是空。
         uint64_t inode_saddr ；快照间的段该值为up快照地址值，非快照区间则是次新inode地址。
         uint64_t timestamp   ；统计时刻时间戳
         uint32_t log_num     ；段中总共的log数据
         uint32_t block_num   ；段中总共的date block数
         uint32_t alive_block_num ；段中活跃块data block数
         uint32_t bitmap_size;位图长度，字节长度。
         char     *alive_log_bitmap；存在有alive block的log位图，暂时粒度到log。每一位对应段中一个log，如果该log中有脏页则标记为1. 
}
这个结构需要能持久化和反持久化——写入磁盘和从磁盘中读取
}}}

= 算法要点 =

* 段统计

 # .先查找段统计文件和段删除标记文件，查看该段是否存在。如果段存在，且在段统计文件中，且又在段删除标志中存在则说明没执行离线段删除，跳过其。如果段已经不存在，也跳过其。
 # .根据段号找到回收过程要使用的参考inode —— 先确定是否该段处于快照区间内，如果在快照区间内，则找到up snapshot对应的inode_addr做参考（注意已有的段统计中记录的inode_addr和当前找到的up snapshot的inode_addr不符合，则说明原有快照被删除，
则需要重新做段统计，否则不需要做）；如果在非快照区间内，则找次新inode（注意已有的段统计中记录的inode_addr和当前找到的次新inode_addr不符，且当前此新inode和记录中的inode跨越的段数超过给定水位，则也要重新计算段统计）。
 # .对于一个段上存在多个快照的情况，目前先不做处理（复杂度较高），该段不做统计，忽略它。
 # .如果统计出某个段的live block为0,不直接删除。而是记录到段删除标记文件中。待后期删除。
 # .我们会跳过段统计文件中存在一些过期项（段统计项中alive block为0，且段文件已经被删除），这些过期项在一定时刻通过rewrite消除。
 # .段统计过程为了调试等目的，我们希望按照段好大小依次进行（也就是按照段生成顺序）。

* 段搬迁

 # 如果段统计文件中某段为的alive block为0，则忽略跳过。
 # 段搬迁操作对于当前inode而言是个类似于“check and modify”的原子操作（check-查询inode是否仍然索引到给定存储块;modify-作为新log追加写要修改inode的索引）。这里关键是要保证对inode查询和修改的原子性（不能让正常写入打断，那样就有可能旧数据块覆盖新数据块了）；而且同时我们希望搬迁动作优先级低于正常写入动作——只有在系统无写压力时才进行搬迁，确定几秒内没有写动作后，才会执行搬迁动作。为此目的我们采用单线程模式实现写入优先级和搬迁的原子性操作。
 # 另外要注意，为了确保写请求能抢占执行，所以搬迁动作粒度不呢太大，每次处理完一个段的搬迁后，就需要检查是否有请求，如果有则要打断搬迁工作，抢占式执行写操作；当再次进入无写状态时，搬迁过程又继续进行。
 # 搬迁完成后修改段统计文件——追加式更新该段的段统计记录。
 # 每轮扫描结束后（扫描了初始时读入的所有段统计文件），下一轮执行前都需要重新加载段统计文件（因为有可能期间统计文件有变）
 # 段搬迁过程为了调试等目的，我们希望按照段好大小依次进行（也就是按照段生成顺序）

= 涉及的几个带外工具 =
 * 段统计（拉模式）工具—— 支持段粒度、区间力度、和全范围统计，即可只扫描给定段，给定区间内的段（给定开始和结束的连续段区），和全部范围段。
 * 段统计（推模式）工具—— 支持区间力度、和全范围统计。
 * 段搬迁离线工具：（确保当前hlfs未挂载情况下使用）。指定水位阀值、支持按照段力度。
 * 段删除工具：扫描段统计文件，发现alive block为0的段文件，进行删除
段统计文件Merge工具：将段统计文件中alive block的段统计记录去除（只有当对应的段不存在时）。

= 伪代码算法描述 =
{{{
段统计逻辑
segs_usage_status(storage_t *storage,uint64_t start_segno,uint64_t end_segno)
{
   GHashTable *seg_usage_hashtable;
   ret = load_all_segment_usage(storage,SEGMENTS_USAGE_FILE,seg_usage_hashtable);
   GList * seg_usage_list = g_hash_table_get_values(seg_usage_hashtable);
   g_slist_sort(seg_usage_list,compare_func);
   uint32_t num_entries;
   bs_file_info_t * file_infos = storage->bs_file_list_dir(storage,"." num_entries);
   for_each_item_in_file_infos{
        if(suffix(file) != "seg"){ /*只找段文件*/
              continue; 
        }
        segno = get_segno(file_info);
        if(segno => start_no && segno <= end_segno){
           segment_usage = get_segment_usage(seg_usage_hashtable);
           if(segment_usage != NULL){/*存在块记录结构，则索命已经执行过块统计操作*/
              ret = get_up_snapshot_by_segno(snapshot_hashtable,segno,snapshot);/*查找指定段上的快照*/
              case ret in{
                SN_NOT_FIND: /*快照已经被删除,需要重新做段统计*/
          	    inode = get_ref_inode(segno,snapshot_hashtable)；/*获取段所在段的参考inode*/
                    __seg_usage_calc(storage,segno,inode,seg_usage,block_size);/*执行实际的计算动作*/ 
                    break;
                SN_FIND:  
                    if(snapshot->inode_addr != segment_usage->inode_addr){/*说明当时参考快照已经改变，需要重新做段统计*/
                    	inode = get_ref_inode(segno,snapshot_hashtable)；/*获取段所在段的参考inode*/
                    	__seg_usage_calc(storage,segno,inode,seg_usage,block_size); /*执行实际的计算动作*/    
                    }
                    break;
                MUTI_SN_FIND:/*发现段上存在多个snapshot，目前不做统计*/
                    break;
               }    
           }else{ /*未执行过块统计操作*/
                inode = get_ref_inode(segno,snapshot_hashtable)；/*获取段所在段的参考inode*/
                __seg_usage_calc(storage,segno,inode,seg_usage,block_size); 
           }
        }
   }
}

/*该函数用于根据段号和快照表找到回收使用的参考inode*/
get_ref_inode(segno，snapshot_hashtable){/*获得参考inode*/
    snapshot_list =  g_hash_table_get_values(segno，snapshot_hashtable);
    g_slist_sort(segno，snapshot_hashtable,compare_func); /*按照段号，即时间序排序*/
    for_each_item_in_snapshots{
        if (get_segno(prev_snapshot->inode_addr) < segno) && (get_segno(cur_snapshot->inode_addr) > segno){
            /* 在快照区间内,获取up snapshot的inode地址；注意如果只有1个快照，区间是段0到当前快照所在段区间，这个要单独处理*/
            inode = load_inode(cur_snapshot->inode_addr);
        }
        pre_snapshot=cur_snapshot;
    }
    inode = semi_latest_inode(); 对于非快照区间的段,获取次新inode地址；
    return inode;
}

__seg_usage_calc(storage,segno,inode,seg_usage,block_size){
   /*见当前实现的segment_usage_calc*/
   /*重做时可以考虑，根据alive_log_bitmap,做一定优化*/
}
int rewrite_alive_blocks_from_seg(ctrl,seg_usage){
   /*见当前实现,但当前实现有一个bug,即我们不能简单的将bitmap中标记为1的log直接搬迁到新日志中，
     因为
     1.bitmap记录的log并非当前时刻仍然存在alive的block，段统计时间和当前搬迁时间有差距，所以要重算。
     2.bitmap中表明某个log存在脏块，而非该log中所有块都脏，所以，我们不能已log为单位将其全部搬迁。
     鉴于上面两个原因，这里的bitmap为1的log，需要和当前inode在做对比，查看是否alive。如果alive的则要搬迁。
     搬迁中还要注意，我们每个log目前是要求连续块的，所以这里的处理颇为麻烦。有可能需要产生更多的小log.
   */
}
}}}

{{{
段强制回收处理逻辑
while(ctrl->write_task_run)
{
   g_get_current_time(&expired);
   g_time_val_add(&expired,1000*1000);
   w_req = (struct write_req*)g_async_queue_timed_pop(ctrl->write_req_aqueue,&expired);
   if(w_req != NULL){
            HLOG_DEBUG("real write request comming");
            int size = append_log(ctrl,w_req->req_buf,w_req->db_start,w_req->db_end);
            //w_rsp = (struct write_rsp*)g_malloc0(sizeof(struct write_rsp));
            if(size < 0){
                HLOG_DEBUG("failed to append log");
                w_rsp->res = -1;
            }else{
                w_rsp->res = 0;
                w_rsp->size = size;
            }
            g_async_queue_push(ctrl->write_rsp_aqueue,(gpointer)w_rsp);
            //g_free(w_req);
            continue; 
   }else{ /*无用户写请求之后，进入强制回收过程*/
     if(seg_idx = -1){ idx归-1则标识一轮结束
         if(seg_usage_hashtable~=NULL){
           destroy(seg_usage_hashtable); 
         }
         if(seg_usage_list!=NULL){
           destroy(seg_usage_hashtable); 
         }
   	 load_all_segment_uasge(seg_usage_hashtable);
   	 seg_usage_list =  g_hash_table_get_values(seg_usage_hashtable);
   	 g_slist_sort(seg_usage_list,compare_func); /*安段号排序*/
   	 seg_idx = 0;
     }
     do{
       struct segment_usage *seg_usage = (struct segment_usage*)g_list_nth_data(seg_usage_list,seg_idx);
       if(is_in_snapshot_range(seg_usage)){
          /*是否是在快照区间*/
          seg_idx++;
          continue;
       }else if(seg_usage->alive_blocks > g_atomic_int_get(&ctrl->ctrl_region->copy_waterlevel)){
          /*未到阀值,则不进行回收*/
          seg_idx++;
          continue;
       }else{
          break;
       }
     }while(seg_idx<=sizeof(seg_usage_list)); //找到需要可进行强制回收的段
     if(seg_idx == sizeof(seg_usage_list){
         seg_idx = -1;
         continue;
     }
     int ret = rewrite_alive_blocks_from_seg(ctrl,seg_usage)；
     dump_segment_usage(ctrl->storage,SEGMENTS_USAGE_FILE,seg_usage->segno);
     seg_idx++; //*每回收一个之后就要去重新检查是否有用户写请求
  }
}   
}}}

--待完善
----
wroten by kanghua
 