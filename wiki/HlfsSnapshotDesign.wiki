#summary HLFS快照设计.
=HLFS snapshot design=                                     

==主要概念说明==
  * 为什么需要快照
  Hosting服务中数据污染（如网站被黑）时,很需要能回滚到已知最近的正常状态.满足这种回滚到某个状态的要求就是快照的目的.
  * 快照的类型—我们将快照分为两种类型：
   #checkpoint：检查点，检查点可以简单的认为是自动快照，也就是说无需外部触发，周期性，或者按某种条件自动触发进行的.在我们hlfs目前写透方式下，其实每写入log就等于进一个checkpoint.这种类型的快照无需重新设计，每个log都是一个天然的检查点.
   #snapshot  ：快照,即用户使用接口运行时创建检查点.这种类型的快照是由用户触发,希望能永久性保留.
  * snapshot的内容
  对应inode存储地址、时间戳、以及用户定义的快照名.
  * snapshot的存储方式
  存储在文件checkpoints.txt中,主要追加方式写入.

==关于snapshot场景下的段回收机制设计==
 # 方案1 - 保留最新时期所有日志.
 该方案我们不再区分checkpoint或者snapshot——snapshot的意义相比checkpoint仅仅多了一个用户给定的标记。对段回收任务来说，只关心旧日志距当前多久。超过给定期限则进行回收（回收方法使用后面描述的“区间回收”），否则保留它。
 # 方案2 - 快照间分区回收。
 假如用户打上了N此永久快照（分别是SS1..SSm-1,SSm,SSm+1..SSn)。那么我们的段回收工作将分成n个子任务，每个子任务负责一段区域内的段回收。
  ** Task1负责SS1快照之前的所有段回收；
  ** Taskm-1 负责SSm-2 到SSm-1 区间内的段回收；
  ** Taskm   负责SSm-1 到SSm   区间内的段回收；
  ** Taskm+1 负责SSm   到SSm+1 区间内的段回收；
  ** Taskn   负责SSn   到当前段的段回收；
 Taskn 的实现按照传统的回收方式进行；其余回收子任务则有所不同（我们称为“区间回收”）
 区间回收实现设计!
 * 段统计：和传统段统计相比:需要变化的是——选择次新inode，变为选择快照时刻对应inode.即Taskx使用SSx对应的inode作为统计时刻的inode.
 * 段清理：区间内实现段清理，对于活跃db统计计数已经为0的段，可以删除.但对于尚有少量活跃数据的段却不容易采用传统回收所使用的move + remove的方式实现.其中一个主要原因是若move一个区间内的一个log，就需要更改其后续的所有SS对应的inode（传统的段清理动作是将move的log写入最新段，从而也伴随更新最新inode，相对简单许多).这显然是一个很重的操作.如何在区间回收中找到一个很好的算法实现move + remove语意，我目前也没想到好办法.
 从上述分析来看，区间回收不能完美实现，退而求其次，只回收那些活跃db为0的那些段文件。 鉴于不能彻底回收的原因，我们为了要避免可能的太多无法回收空间，同时也简化涉及的目的，比较现实的做法是采用：<br>
 _退化的区间回收算法（不move + revmode)+时间超期限制(过期则必然回收，即便有快照)_

==关于树形快照的设计==
http://cloudxy.googlecode.com/svn/wiki/images/tree-snapshot.png

未完，待续 ...........................................................


==API设计==
 我们先实现最精简的快照接口
{{{
 int take_snapshot(HLFS_CTRL *ctrl, const char *ssname)
  给用户提供的在线方式快照接口，用户可以指定快照名
  * ctrl: 全局控制结构体
  * ssname: 用户指定的快照名
  * return value: 成功返回0，失败返回<0
 int rm_snapshot(const char *uri, const char *ssname)
  用户可以通过这个接口来删除指定名字的快照
  * uri: 文件系统的位置 
  * ssname: 用户指定的快照名
  * return value: 成功返回0，失败返回<0
 int find_inode_before_time(const char *uri, uint64_t time,uint64_t* inode_addr)
  用户可以通过这个接口来获取timestamp之前的inode存储地址
  * uri: 文件系统的位置 
  * time: 用户指定的时间
  * inode_addr 返回inode存储地址。
  * return value: 成功返回0,失败返回<0
 int find_inode_by_name(const char *uri, const char *ssname,uint64_t* inode_addr)
  用户可以通过这个接口来获取指定名字的快照记录的inode存储地址
  * uri: 文件系统的位置 
  * ssname: 用户指定的快照名
  * inode_addr 返回inode存储地址
  * return value: 成功返回0,失败返回<0
 int get_inode_info(const char *uri,uint64_t inode_addr, uint64_t *creat_time, uint64_t *length)
  获取指定inode的创建时间和文件长度
  * uri: 文件系统的位置 
  * inode_addr: 指定的inode存储地址
  * creat_time: 创建时间将存放在这里
  * length: 文件长度将存放在这里
  * return value: 成功返回0，失败返回<0
 int hlfs_open_by_inode(HLFS_CTRL *ctrl,uint64_t inode_addr,int flag)
  加载指定的inode，以flag标识的模式启动回滚
  * ctrl : 全局控制结构
  * inode: 指定的inode
  * flag: 0 只读模式， 1 可写模式
  * return value: 成功返回0，失败返回<0
 int list_all_snapshot(const char *uri，char* ss_name_array)
  给用户列出所有已存在的快照名及时间信息
  * uri: 文件系统的位置 
  * ss_name_arrary: 返回的快照名字列表
  * return value: 成功返回0，失败返回<0
}}}
==API使用指南==
  * 快照： 在线模式调用take_snapshot()函数
  * 获取快照清单：离线模式调用list_all_snapshot()
  * 删除指定名字的快照：离线模式调用rm_snapshot()
  * 回滚到检查点：调用find_inode_before_time获得inode结构体，然后调用get_inode_info()获取inode信息，根据该信息判断是否满足用户要求，则启动回滚——调用init_hlfs()获得全局控制结构，并以只读或者是可写模式调用hlfs_open_by_inode()
  * 回滚到快照：调用find_inode_by_name获得inode结构体，启动回滚——调用init_hlfs()获得全局控制结构，并以只读或者是可写模式调用hlfs_open_by_inode()